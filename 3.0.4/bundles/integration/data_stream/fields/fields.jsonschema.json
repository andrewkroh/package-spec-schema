{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "array",
  "items": {
    "type": "object",
    "allOf": [
      {
        "if": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "aggregate_metric_double"
            }
          }
        },
        "then": {
          "required": [
            "default_metric"
          ],
          "properties": {
            "default_metric": {
              "$ref": "#/definitions/metric_aggregation"
            }
          }
        },
        "else": {
          "not": {
            "required": [
              "default_metric"
            ]
          }
        }
      },
      {
        "if": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "aggregate_metric_double"
            }
          }
        },
        "then": {
          "required": [
            "metrics"
          ],
          "properties": {
            "metrics": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/metric_aggregation"
              }
            }
          }
        },
        "else": {
          "not": {
            "required": [
              "metrics"
            ]
          }
        }
      },
      {
        "if": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "enum": [
                "boolean",
                "date",
                "double",
                "geo_point",
                "ip",
                "keyword",
                "long"
              ]
            }
          }
        },
        "then": {
          "properties": {
            "runtime": {
              "$ref": "#/definitions/runtime"
            }
          }
        },
        "else": {
          "not": {
            "required": [
              "runtime"
            ]
          }
        }
      },
      {
        "if": {
          "not": {
            "required": [
              "object_type"
            ]
          },
          "required": [
            "metric_type"
          ]
        },
        "then": {
          "oneOf": [
            {
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "histogram",
                    "aggregate_metric_double",
                    "long",
                    "integer",
                    "short",
                    "byte",
                    "double",
                    "float",
                    "half_float",
                    "scaled_float",
                    "unsigned_long"
                  ]
                }
              }
            },
            {
              "required": [
                "external"
              ]
            }
          ]
        }
      },
      {
        "if": {
          "required": [
            "object_type"
          ]
        },
        "then": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "enum": [
                "object"
              ]
            }
          }
        }
      },
      {
        "if": {
          "required": [
            "metric_type",
            "object_type"
          ],
          "properties": {
            "type": {
              "const": "object"
            }
          }
        },
        "then": {
          "required": [
            "type",
            "object_type"
          ],
          "properties": {
            "object_type": {
              "enum": [
                "histogram",
                "long",
                "integer",
                "short",
                "byte",
                "double",
                "float",
                "half_float",
                "scaled_float",
                "unsigned_long"
              ]
            },
            "type": {
              "enum": [
                "object"
              ]
            }
          }
        }
      },
      {
        "if": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "object"
            }
          }
        },
        "then": {
          "oneOf": [
            {
              "required": [
                "object_type"
              ],
              "properties": {
                "enabled": {
                  "const": true
                }
              }
            },
            {
              "not": {
                "required": [
                  "object_type"
                ]
              },
              "required": [
                "enabled"
              ],
              "properties": {
                "enabled": {
                  "const": false
                }
              }
            }
          ]
        }
      },
      {
        "if": {
          "required": [
            "fields"
          ],
          "properties": {
            "fields": {
              "minContent": 1
            }
          }
        },
        "then": {
          "properties": {
            "type": {
              "enum": [
                "group",
                "nested"
              ]
            }
          }
        }
      },
      {
        "if": {
          "required": [
            "subobjects"
          ]
        },
        "then": {
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "enum": [
                "object"
              ]
            }
          }
        }
      }
    ],
    "required": [
      "name"
    ],
    "properties": {
      "analyzer": {
        "description": "Name of the analyzer to use for indexing. Unless search_analyzer is specified this analyzer is used for both indexing and searching. Only valid for 'type: text'.\n",
        "type": "string"
      },
      "copy_to": {
        "description": "The copy_to parameter allows you to copy the values of multiple fields into a group field, which can then be queried as a single field.\n",
        "type": "string"
      },
      "date_format": {
        "description": "The date format(s) that can be parsed. Type date format default to `strict_date_optional_time||epoch_millis`, see the [doc](https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#date-params).\nIn JSON documents, dates are represented as strings. Elasticsearch uses a set of preconfigured formats to recognize and parse these strings into a long value representing _milliseconds-since-the-epoch_ in UTC.\nBesides the [built-in formats](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#built-in-date-formats), your own [custom formats](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats) can be specified using the familiar `yyyy/MM/dd` syntax.\n",
        "type": "string"
      },
      "default_metric": true,
      "description": {
        "description": "Short description of field",
        "type": "string"
      },
      "dimension": {
        "description": "Declare a field as dimension of time series. This is attached to the field as a `time_series_dimension` mapping parameter.\n",
        "default": false,
        "type": "boolean"
      },
      "doc_values": {
        "description": "Controls whether doc values are enabled for a field. All fields which support doc values have them enabled by default. If you are sure that you don’t need to sort or aggregate on a field, or access the field value from a script, you can disable doc values in order to save disk space. You cannot disable doc values for wildcard fields.\n",
        "type": "boolean"
      },
      "dynamic": {
        "description": "The dynamic parameter controls whether new fields are added dynamically. It accepts the following values:\ntrue -  New fields are added to the mapping (default).\nruntime - New fields are added to the mapping as runtime fields. These fields are not indexed, and are loaded from _source at query time.\nfalse - New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.\nstrict -  If new fields are detected, an exception is thrown and the document is rejected. New fields must be explicitly added to the mapping.\n",
        "default": true,
        "enum": [
          true,
          false,
          "strict",
          "runtime"
        ]
      },
      "enabled": {
        "description": "The enabled setting, which can be applied only to the top-level mapping definition and to object fields, causes Elasticsearch to skip parsing of the contents of the field entirely. The JSON can still be retrieved from the _source field, but it is not searchable or stored in any other way.\n",
        "type": "boolean"
      },
      "example": {
        "description": "Example values for this field.",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          },
          {
            "type": "null"
          },
          {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                }
              ]
            }
          },
          {
            "type": "object"
          }
        ]
      },
      "expected_values": {
        "description": "An array of expected values for the field. When defined, these are the only expected values.",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "external": {
        "description": "External source reference",
        "type": "string",
        "enum": [
          "ecs"
        ]
      },
      "fields": {
        "description": "Sub-fields, when type is group",
        "$ref": "#"
      },
      "ignore_above": {
        "description": "Strings longer than the ignore_above setting will not be indexed or stored. For arrays of strings, ignore_above will be applied for each array element separately and string elements longer than ignore_above will not be indexed or stored. Fleet honors this for `keyword` and `wildcard` types. Defaults to 1024.\n",
        "default": 1024,
        "type": "integer"
      },
      "ignore_malformed": {
        "description": "Trying to index the wrong data type into a field throws an exception  by default, and rejects the whole document. The ignore_malformed  parameter, if set to true, allows the exception to be ignored. The  malformed field is not indexed, but other fields in the document are  processed normally. Defaults to false.\n",
        "default": false,
        "type": "boolean"
      },
      "include_in_parent": {
        "description": "For nested field types, this specifies if all fields in the nested object are also added to the parent document as standard (flat) fields.\n",
        "default": false,
        "type": "boolean"
      },
      "include_in_root": {
        "description": "For nested field types, this specifies if all fields in the nested object are also added to the root document as standard (flat) fields.\n",
        "default": false,
        "type": "boolean"
      },
      "index": {
        "description": "The index option controls whether field values are indexed. Fields that are not indexed are typically not queryable.\n",
        "default": true,
        "type": "boolean"
      },
      "metric_type": {
        "description": "The metric type of a numeric field. This is attached to the field as a `time_series_metric` mapping parameter. A gauge is a single-value measurement that can go up or down over time, such as a temperature. A counter is a single-value cumulative counter that only goes up, such as the number of requests processed by a web server. By default, no metric type is associated with a field.\n",
        "type": "string",
        "enum": [
          "counter",
          "gauge"
        ]
      },
      "metrics": true,
      "multi_fields": {
        "description": "It is often useful to index the same field in different ways for different purposes. This is the purpose of multi-fields. For instance, a string field could be mapped as a text field for full-text search, and as a keyword field for sorting or aggregations.\nFleet honors this for `keyword`, `text`, and `wildcard` types.\n",
        "$ref": "#"
      },
      "name": {
        "description": "Name of field. Names containing dots are automatically split into sub-fields. Names with wildcards generate dynamic mappings.\n",
        "type": "string",
        "pattern": "^[\\-*_\\/@A-Za-z0-9]+(\\.[\\-*_\\/@A-Za-z0-9]+)*$"
      },
      "normalize": {
        "description": "Specifies the expected normalizations for a field. `array` normalization implies that the values in the field should always be an array, even if they are single values.\n",
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "array"
          ]
        }
      },
      "normalizer": {
        "description": "Specifies the name of a normalizer to apply to keyword fields. A simple normalizer called lowercase ships with elasticsearch and can be used. Custom normalizers can be defined as part of analysis index settings.\n",
        "type": "string"
      },
      "null_value": {
        "description": "The null_value parameter allows you to replace explicit null values with the specified value so that it can be indexed and searched.\nA null value cannot be indexed or searched. When a field is set to null, (or an empty array or an array of null values) it is treated as though that field has no values.\nThe null_value needs to be the same data type as the field. For instance, a long field cannot have a string null_value.\nThe null_value only influences how data is indexed, it doesn’t modify the _source document.\n",
        "examples": [
          "NULL"
        ]
      },
      "object_type": {
        "description": "Type of the members of the object when `type: object` is used. In these cases a dynamic template is created so direct subobjects of this field have the type indicated. When `object_type_mapping_type` is also used, the dynamic mapping is only applied to values that have the given type, as detected by the JSON parser.\n",
        "type": "string",
        "enum": [
          "boolean",
          "byte",
          "double",
          "float",
          "histogram",
          "keyword",
          "long",
          "object",
          "short",
          "text",
          "integer",
          "half_float",
          "scaled_float",
          "unsigned_long"
        ]
      },
      "object_type_mapping_type": {
        "description": "Type that members of a field of with `type: object` must have in the source document. This type corresponds to the data type detected by the JSON parser, and is translated to the `match_mapping_type` parameter of Elasticsearch dynamic templates.\n",
        "type": "string",
        "enum": [
          "*",
          "array",
          "double",
          "false",
          "long",
          "null",
          "object",
          "string",
          "true"
        ]
      },
      "path": {
        "description": "For alias type fields this is the path to the target field. Note that this must be the full path, including any parent objects (e.g. object1.object2.field).\n",
        "type": "string"
      },
      "pattern": {
        "description": "Regular expression pattern matching the allowed values for the field. This is used for development-time data validation.\n",
        "examples": [
          "^[a-zA-Z]$"
        ],
        "type": "string"
      },
      "runtime": true,
      "scaling_factor": {
        "description": "The scaling factor to use when encoding values. Values will be multiplied by this factor at index time and rounded to the closest long value. For instance, a scaled_float with a scaling_factor of 10 would internally store 2.34 as 23 and all search-time operations (queries, aggregations, sorting) will behave as if the document had a value of 2.3. High values of scaling_factor improve accuracy but also increase space requirements. Only valid for 'type: scaled_float'.\n",
        "default": 1000,
        "type": "integer"
      },
      "search_analyzer": {
        "description": "Name of the analyzer to use for searching. Only valid for 'type: text'.\n",
        "type": "string"
      },
      "subobjects": {
        "description": "Specifies if field names containing dots should be expanded into subobjects. For example, if this is set to `true`, a field named `foo.bar` will be expanded into an object with a field named `bar` inside an object named `foo`.\n",
        "default": true,
        "type": "boolean"
      },
      "type": {
        "description": "Datatype of field. If the type is set to object, a dynamic mapping is created. In this case, if the name doesn't contain any wildcard, the wildcard is added as the last segment of the path.\n",
        "type": "string",
        "enum": [
          "aggregate_metric_double",
          "alias",
          "histogram",
          "constant_keyword",
          "text",
          "match_only_text",
          "keyword",
          "long",
          "integer",
          "short",
          "byte",
          "double",
          "float",
          "half_float",
          "scaled_float",
          "date",
          "date_nanos",
          "boolean",
          "binary",
          "integer_range",
          "float_range",
          "long_range",
          "double_range",
          "date_range",
          "ip_range",
          "group",
          "geo_point",
          "object",
          "ip",
          "nested",
          "flattened",
          "wildcard",
          "version",
          "unsigned_long"
        ]
      },
      "unit": {
        "description": "Unit type to associate with a numeric field. This is attached to the field as metadata (via `meta`). By default, a field does not have a unit. The convention for percents is to use value 1 to mean 100%.\n",
        "type": "string",
        "enum": [
          "byte",
          "percent",
          "d",
          "h",
          "m",
          "s",
          "ms",
          "micros",
          "nanos"
        ]
      },
      "value": {
        "description": "The value to associate with a constant_keyword field.",
        "type": "string"
      }
    },
    "patternProperties": {
      "^(default_field|norms)$": {
        "type": "boolean"
      },
      "^(footnote|format|title)$": {
        "type": "string"
      },
      "^(level|group)$": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "integer"
          }
        ]
      }
    },
    "additionalProperties": false
  },
  "definitions": {
    "metric_aggregation": {
      "type": "string",
      "enum": [
        "min",
        "max",
        "sum",
        "value_count",
        "avg"
      ]
    },
    "runtime": {
      "description": "Specifies if this field is evaluated at query time. If it is set to true, it creates a runtime script with `params._source['<field>']`. If this field is a string, it creates the runtime script using this string set in the definition. More info at https://www.elastic.co/guide/en/elasticsearch/reference/current/runtime-mapping-fields.html\n",
      "examples": [
        true,
        "doc['message'].value().doSomething()"
      ],
      "default": false,
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "boolean"
        }
      ]
    }
  }
}
